/**
 * @fileoverview A middleware for CSRF mitigation, using either the
 * synchronizer token or the double submission cookie pattern (see
 * [OWASP CSRF Prevention Cheat Sheet](https://www.owasp.org/index.php/Cross-Site_Request_Forgery_%28CSRF%29_Prevention_Cheat_Sheet)
 * for a detailed explanation).
 *
 * This middleware extends the request object by adding two methods:
 * - `getCsrfToken()` returns the CSRF token value for the current request,
 * creating and storing it in the current session if necessary
 * - `rotateCsrfToken()` creates a new CSRF token and stores it in the current session
 *
 * Use `getCsrfToken()` of the request object to add the token value as
 * hidden input to all forms generated by the application, and make sure the
 * name of the form input is configured accordingly (defaults to "csrftoken").
 *
 * The token value returned by `getCsrfToken()` is additionally stored either
 * in the current session (default) or in a cookie. The POST parameter and
 * the token value stored are compared, and in case of a mismatch this
 * middleware returns a 403 "Forbidden" response.
 *
 * For non-POST requests this middleware accepts the token sent as query
 * parameter or custom header field.
 *
 * ### Configuration options:
 *
 * `app.csrf()` accepts an object as parameter containing the following
 * properties (default values in brackets):
 *
 * - `tokenLength`: The length of the CSRF token (32)
 * - `checkReferrer`: Enable strict referrer checking for HTTPS requests (true)
 * - `rotate`: If true tokens are only used once and modified after each validation (false)
 * - `getToken`: By default the middleware expects the submitted CSRF token in
 * either a post or query parameter `csrftoken` or in a custom request header
 * `x-csrf-token` (in this order). To customize this define a function
 * that will receive the request object as single argument and is expected
 * to return the CSRF token (or null).
 * - `getFailureResponse`: An optional function receiving the request as single argument.
 * This method is called if the CSRF validation failed, and is expected to return
 * a valid JSGI response (default: 403 forbidden).
 * - `safeMethods`: An array containing request method names that are
 * considered safe, so no token validation is done (["GET", "HEAD", "OPTIONS", "TRACE"])
 *
 * #### Cookie mode
 *
 * The following options switch the middleware into "double submission cookie" mode,
 * and allow detailed configuration of the cookie:
 *
 * - `useCookie`: If true the CSRF token is stored in a cookie
 * - `cookieName`: The name of the cookie to set ("csrftoken")
 * - `cookieHttpOnly`: If true the `httpOnly` flag of the cookie is set (true)
 * - `cookieSecure`: If true the `secure` flag of the cookie is set (false)
 *
 * @example
 * app.configure("csrf");
 * app.csrf({
 *     "tokenLength": 64,
 *     "rotate": true,
 *     "getToken": function(req) {
 *         return req.headers["x-custom-field"];
 *     }
 * });
 */
var log = require("ringo/logging").getLogger(module.id);

var {SecureRandom} = java.security;
var {ByteArray} = require("binary");
var response = require("ringo/jsgi/response");
var {setCookie} = require("ringo/utils/http");
var {URL} = java.net;

var TOKEN_CHARS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
var TOKEN_LENGTH = 32;

var RANDOM_PRNG = "SHA1PRNG";
var RANDOM_PROVIDER = "SUN";

var COOKIE_NAME = "csrftoken";
var COOKIE_HTTPONLY = true;
var COOKIE_SECURE = false;

var SAFE_METHODS = ["GET", "HEAD", "OPTIONS", "TRACE"];
var NAME_POST = "csrftoken";
var NAME_QUERY = "csrftoken";
var NAME_HEADER = "x-csrf-token";

/**
 * The random generator used for creating tokens
 * @type {java.security.SecureRandom}
 */
var random = SecureRandom.getInstance(RANDOM_PRNG, RANDOM_PROVIDER);

/**
 * Returns a random string with the given length
 * @param {Number} len The length of the string to return
 * @returns {String} The random string
 */
var generateCsrfToken = function(len) {
    var buf = [];
    for (let i=0; i<len; i+=1) {
        buf.push(TOKEN_CHARS[random.nextInt(TOKEN_CHARS.length)]);
    }
    return buf.join("");
};

/**
 * Returns true if the tokens passed as argument are equal
 * @param {String} token The token
 * @param {String} sessionToken The session token value
 * @returns {Boolean} True if the tokens are equal, false otherwise
 */
var isValidCsrfToken = function(token, sessionToken) {
    if (typeof(token) !== "string" || typeof(sessionToken) !== "string") {
        log.debug("Missing or incorrect CSRF token");
        return false;
    }
    return equals(token.toByteArray(), sessionToken.toByteArray());
};

/**
 * Compares the two byte arrays in constant time to prevent timing attacks
 * @param {ByteArray} bytesA The byte array to compare
 * @param {ByteArray} bytesB The byte array to compare to
 * @returns {Boolean} True if the byte arrays are equal, false otherwise
 */
var equals = function(bytesA, bytesB) {
    var diff = bytesA.length ^ bytesB.length;
    if (diff != 0) {
        return false;
    }
    for (let i=0; i<bytesA.length && i<bytesB.length; i+=1) {
        diff |= bytesA[i] ^ bytesB[i];
    }
    return diff == 0;
};

/**
 * Returns true if the referrer scheme, host and port match
 * the request.
 * @param {JSGIRequest} req The JSGI request
 * @returns {Boolean} True if referrer and request are from the same origin
 */
var isSameOrigin = function(req) {
    if (req.remoteAddress.length === 0) {
        return false;
    }
    try {
        var url = new URL(req.remoteAddress);
        var protocol = url.getProtocol();
        var host = url.getHost();
        var port = url.getPort();
        if (port === -1) {
            port = url.getDefaultPort();
        }
        return protocol === "https" && req.host === host && req.port === port;
    } catch (e) {
        return false;
    }
};

/**
* Stick middleware factory for CSRF mitigation
* @param {Function} next the wrapped middleware chain
* @param {Object} app the Stick Application object
* @returns {Function} a JSGI middleware function
*/
exports.middleware = function csrf(next, app) {

    /**
     * The default configuration
     * @type {Object}
     */
    var config = {
        "useCookie": false,
        "checkReferrer": true,
        "tokenLength": TOKEN_LENGTH,
        "rotate": false,
        "cookieName": COOKIE_NAME,
        "cookieHttpOnly": COOKIE_HTTPONLY,
        "cookieSecure": COOKIE_SECURE,
        "safeMethods": SAFE_METHODS,
        "getToken": function(req) {
            return req.postParams[NAME_POST] ||
                    req.queryParams[NAME_QUERY] ||
                    req.headers[NAME_HEADER] || null;
        },
        "getFailureResponse": function(req) {
            return response.forbidden();
        }
    };

    /**
     * Configures the CSRF middleware
     * @param {Object} conf The configuration options
     */
    app.csrf = function(conf) {
        for each (let [key, value] in Iterator(conf)) {
            if (config.hasOwnProperty(key)) {
                config[key] = value;
            } else {
                throw new Error("Unknown config option '" + key + '"');
            }
        }
    };

    /**
     * The middleware function
     */
    return function csrf(req) {
        var useCookie = config.useCookie === true;
        var doSetCookie = false;
        var token = null;
        if (useCookie === true) {
            if (!req.cookies) {
                throw new Error("CSRF requires params and cookies middleware");
            }
            token = req.cookies[config.cookieName];
        } else {
            if (!req.session) {
                throw new Error("CSRF requires params and session middleware");
            }
            token = req.session.data.csrfToken || null;
        }

        Object.defineProperties(req, {
            /**
             * Returns the current token value. If none exists this
             * method creates a new CSRF token and stores it in either
             * the session or in a cookie, depending on configuration.
             */
            "getCsrfToken": {
                "value": function() {
                    return token || this.rotateCsrfToken();
                }
            },
            /**
             * Creates a new CRSF token and stores it. This method can
             * be called ie. after successful authentication.
             */
            "rotateCsrfToken": {
                "value": function() {
                    token = generateCsrfToken(config.tokenLength);
                    if (!(doSetCookie = useCookie)) {
                        return this.session.data.csrfToken = token;
                    }
                    return token;
                }
            }
        });

        var res;
        if (config.safeMethods.indexOf(req.method) > -1) {
            // the request method is considered "safe", so skip any validation
            res = next(req, app);
        } else {
            if (config.checkReferrer === true &&
                    req.env.servletRequest.isSecure() && !isSameOrigin(req)) {
                res = config.getFailureResponse(req);
            } else {
                var reqToken = config.getToken(req);
                if (!isValidCsrfToken(reqToken, token)) {
                    res = config.getFailureResponse(req);
                    token = req.rotateCsrfToken();
                } else {
                    if (config.rotate === true) {
                        token = req.rotateCsrfToken();
                    }
                    res = next(req, app);
                }
            }
        }
        if (doSetCookie) {
            res.headers["Set-Cookie"] = setCookie(config.cookieName, token, -1, {
                "httpOnly": config.cookieHttpOnly,
                "secure": config.cookieSecure
            });
            res.headers["Vary"] = "Cookie";
        }
        return res;
    };
};